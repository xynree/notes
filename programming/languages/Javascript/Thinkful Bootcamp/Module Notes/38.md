# 38 : Creating Relations

## Database Relationships

- One-to-one: Each row in a table is connected to a single record in another table
  - ex: driver has one license, and each license has one drive associated
  - ex: person has one name, name belongs to one person
- One-to-many: Each record in table can relate to zero, one, or many records in another table
  - "one" side: Primary Table
  - "many" side: Related Table
  - ex: state can have many cities, many cities can belong to same state
  - ex: artist has many songs, many songs belong to same artist
- Many-to-many: multiple records in one table related to multiple records in another table
  - ex: doc w/ many patients, patient can see many doctors
  - ex: book can have 1+ authors, author may have written multiple books.

- Intermediate Table: Join Table
  - 2 foreign key columns store relationships

- Entity Relationship Diagrams
  - allows db designers to visualize


# Relating Tables Through Keys

- Composite Key: primary key created from combining multiple cols to guarantee uniqueneess

- Referencing other tables:

### One to One

`<column name> <data type> REFERENCES <foreign table name>(<foreign column>)
`
```sql:dpts_table
CREATE TABLE departments
(
  department_id INTEGER PRIMARY KEY generated by default AS identity,
  department_name VARCHAR(100) NOT NULL,
  manager INTEGER REFERENCES employees(employee_id) unique -- Foreign key
);
```

- setting `unique` enforces one-to-one

### One to Many


```sql:customers_table
DROP TABLE if exists customers;

CREATE TABLE customers
(
  customer_id INTEGER PRIMARY KEY generated by default AS identity,
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  phone VARCHAR(100),
  email VARCHAR(100),
  street VARCHAR(255),
  city VARCHAR(100),
  zip_code VARCHAR(5)
);
```

```sql:orders_table
DROP TABLE if exists orders;

CREATE TABLE orders
(
  order_id INTEGER PRIMARY KEY generated by default AS identity,
	order_status INTEGER NOT NULL,
  order_date DATE NOT NULL,
	shipped_date DATE,
  customer_id INTEGER REFERENCES customers(customer_id) NOT NULL -- Foreign key
);
```

Related table references the primary Table field's primary id

### Many to Many

```sql:projects_table
CREATE TABLE projects
(
  project_id INTEGER PRIMARY KEY generated by default AS identity,
  project_name VARCHAR(255) NOT NULL,
  budget NUMERIC DEFAULT 0,
  start_date DATE,
  end_date DATE
);
```

```sql:employee_projects_jointable
CREATE TABLE employees_projects
(
  employee_id INTEGER REFERENCES employees(employee_id),
  project_id INTEGER REFERENCES projects(project_id),
  start_date DATE,
  end_date DATE,
  PRIMARY KEY (employee_id, project_id) -- Composite key
);
```

- Each row in join table links an employee to a project with 2 foreign key columns
- Composite key is used to validate two

# Joining Tables

`SELECT <columns>
FROM <table1>
  JOIN <table2>
  ON <related columns>;`

Aliases:

```sql:alias
SELECT
  c.first_name as customer_name, -- Alias `first_name` as `customer_name`
  c.email,
  o.order_status,
  o.order_date
FROM
  customers c
  INNER JOIN
  orders o
  ON c.customer_id = o.customer_id;
```

# Other Joins

- Outer Joins: LEFT JOIN, RIGHT JOIN, FULL JOIN

- LEFT JOIN
- if one table is listed first in FROM clause, it's considered as left of join, other one is on the right

```sql
SELECT
  d.department_id AS id,
  d.department_name AS department,
  e.first_name AS manager_first_name,
  e.last_name AS manager_last_name
FROM
  departments d
  LEFT JOIN -- Specify `LEFT JOIN` here
  employees e
  ON d.manager = e.employee_id;
```

RIGHT JOIN
- includes all rows on right of a join whether it matches a row on left or not.


FULL JOIN
- gets results of both LET JOIN / RIGHT JOIN.
- returns all rows where ithere is a match in left or right table
